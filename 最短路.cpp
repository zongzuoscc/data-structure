//最短路    n表示点的数量  m表示边的数量
//1 单源最短路  求一个点到其他所有点的最短的距离  从1号点到n号点的最短路
    //1.1 所有边权都是正数  （有两种方法，其实是一种，只是适用于不同的场景）
        //dijkstra基于贪心
        //1.1.1  朴素的dijkstra算法   （时间复杂度是n^2）  与边无关 适合于稠密图 
        //如果稠密图用堆优化版dijkstra算法  m和n^2差不多是一个级别  时间复杂度将是n^2logn
        //1.1.2  堆优化版的dijkstra算法  （时间复杂度是  mlogn）
        //如果是一个稀疏图 m和n是一个级别的  m和n都是10000级别  此时就不能用朴素版dijkstra算法  n^2为10^10
    //1.2 存在负权边
        //bellman-ford算法基于离散数学知识
        //1.2.1bellman-ford算法  时间复杂度为O(nm)
        //1.2.2  SPFA 是bellman-ford 算法的优化  平均的时间复杂度是线性的为 O(m)   最差的情况是O(nm)
        //虽然说SPFA算法是bellman-ford 算法的优化 但并不是所有情况下都可以用SPFA算法
        //比如说规定通过的变数小于等于k  那么就只能用bellman-Ford算法做


//2 多源汇最短路  源点就是起点  汇点一般来说就是终点   多源汇最短路 就是说不只有一个起点
//可能会有很多个询问  任选两个点  从一个点到另外一个点的最短距离  起点和终点都是不确定的
//只有一种做法 Floyd算法  时间复杂度为O(n^3)
//Floyd基于动态规划

//最短路算法 考察的侧重点是 建图同时也是难点 如何把问题抽象成最短路的问题

//朴素版dijkstra    集合s 存储当前已经确立最短路的点
    //1 初始化距离 dist[1]=0; dist[i]=正无穷
    //2 迭代循环的过程 for(i=0;i<n;i++)循环n次  找到不在s中的 距离最近的点  把这个点t加到s中 然后用t来更新其他点的距离
    //更新方式 t可以走到下一个点x  其实就是看dist[x]是不是大于dist[t]
    //就是看从1到t+从t到x 是不是大于从1 到x
    //如果大于 就更新  
    //每次都能确定最短距离  循环n次就能确定所有点的最短距离
    //当前还没有确定的点当中 距离最小的一个点那么这个点的距离一定是最短路

    //由于是一个稠密图  那么我们就使用稠密图来存储 
    //
#include <iostream>
#include <cstring>
#include <algorithm>
using namespace std;
const int N=100010;
int main()
{
    
}