//不是stl的堆，而是自己手写的堆
//如何手写一个堆

//堆最基本的三个操作
//1 插入一个数     heap[++size]=x;在整个堆的最后一位加上一个x  然后把这个数不断往上移 up(size)
//2 求这个集合当中的最小值   直接heap[1] 堆顶一定是最小的
//3 删除最小值    用整个堆的最后一个元素来覆盖堆顶元素， size--  然后再进行调整，把堆顶down   heap[1]=heap[size]  size--  down(1)
//下面这两个操作stl的堆实现不了  或者说是无法直接实现
//4 删除任意一个元素   heap[k]=heap[size] size-- 因为k的值不确定，所以直接down一遍再up一遍 down(k) up(k)  只会执行一个操作
//5 修改任意一个元素   heap[k]=x  down(k)  up(k)
//堆是一个完全二叉树，除了最后一层节点之外
//以小根堆为例  每一个点都小于等于左右两个点的值 根节点就是最小值
//和链表存储不同，是一种全新的存储方式  用一个一维数组来存储  完全二叉树都是这么存的
//1号点是根节点节点x的左节点（就是说左下方的节点）下标是2x，右节点是2x+1
//有两个基本操作 刚刚提到的五个基本操作可以用以下两个操作组合实现
/*
down(x)  向下调整的时候要比较大小，和子节点最小的相互交换位置  其实是一个递归的过程
{
    往下调整
}
*/
/*
up(x)  每次只需要比父节点就好了
{
    往上调整
}

up 和down 时间复杂度和树的高度成正比 所以时间复杂度是O(log n)  插入删除也是
求最小值是O(1)
*/
//如何建堆  如果一个一个往里插，时间复杂度是n log n
//堆 其实也是一种排序，和最开始的快排，归并都是排序的一种

//以下为小根堆的写法
#include <iostream>
#include <algorithm>
using namespace std;
const int N=100010;
int n,m;
int h[N];//h 就是heap
int cnt;//存储的是当前这个数组里有多少个元素
void down(int u)  //一个递归的过程
{
    int t=u;
    if(u*2<=cnt&&h[u*2]<h[t])  //判断是否有左节点而且是否小于当前节点的值
    {
        t=u*2;
    }
    if(u*2+1<=cnt&&h[u*2+1]<h[t])
    {
        t=u*2+1;
    }
    //最后t存的就是三个点里面最小的那个的编号
    if(u!=t)//u!=t说明根节点存储的就不是最小值  这是为什么 
    {
        //那么根节点就需要和最小的交换一下
        swap(h[u],h[t]);
        down(t);//递归处理
    }
}
void up(int u)
{
    while(u/2>0&&h[u/2]>h[u])
    {
        swap(h[u/2],h[u]);
        u/2;
    }
}
int  main()
{
    cin>>n>>m;
    for(int i=1;i<=n;i++)
    {
        cin>>h[i];
    }
    cnt=n;
    for(int i=n/2;i;i--)  //这个建堆方式时间复杂度是O(n)
    {
        down(i);//从n/2 down到1即可
    }
    while(m--)
    {
        cout<<h[1]<<" ";
        h[1]=h[cnt];
        cnt--;
        down(1);
    }
    return 0;
}