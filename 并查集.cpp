//面试或者比赛都很容易出的数据结构  因为代码很短，而且思路精巧
//可以快速地维护一些操作
//并查集可以1：将两个集合合并  2：询问两个元素是否在一个集合当中
//并查集可以在近乎O(1)的时间内完成这两个操作
//用树的形式来维护每一个集合  每一个集合的编号是根节点的编号，对于每一个节点，都存储他的父节点是谁
//当我们要找某一个元素是属于哪一个集合的时候，就依次寻找父节点，直到找到根节点即可判断
//p[x]来表示x的父节点
//问题1 如何判断树根if(p[x]==x) 除了根节点之外，p[x]都不等于x
//问题2 如何求x的集合编号 while(p[x]!=x) x=p[x];只要不是树根，就一直往上走，直到走到树根  如果不优化的话，这一步会导致时间复杂度很高
//并查集优化  就是在找根节点的过程中，一旦找到根节点，就把路径上所有的节点都指向根节点  加完这个优化之后基本上就可以堪称o(1)的时间复杂度
//这个优化叫路径压缩，还有一个优化叫按秩合并  问题 为什么不在一开始建立树的时候就直接全部都指向根节点呢
//问题3 如何合并两个集合  px是x的集合编号 py是y的集合编号  p[x]=y
#include <iostream>
using namespace std;

const int N=100010;

int main()
{

}